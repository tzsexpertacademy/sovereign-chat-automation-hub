import { supabase } from "@/integrations/supabase/client";
import { customersService } from "./customersService";

export interface ConversationTicket {
  id: string;
  client_id: string;
  chat_id: string;
  instance_id: string;
  title: string;
  status: string;
  priority: number;
  created_at: string;
  updated_at: string;
  last_message_at: string;
  last_message_preview: string;
  customer_id?: string;
  assigned_queue_id?: string;
  assigned_assistant_id?: string;
  tags?: string[];
  customer?: {
    id: string;
    client_id: string;
    name: string;
    phone: string;
  };
  assigned_queue_name?: string;
}

export interface TicketMessage {
  id: string;
  ticket_id: string;
  message_id: string;
  from_me: boolean;
  sender_name: string;
  content: string;
  message_type: string;
  timestamp: string;
  is_internal_note: boolean;
  is_ai_response: boolean;
  ai_confidence_score?: number;
  processing_status: string;
  media_url?: string;
}

export const ticketsService = {
  async getClientTickets(clientId: string): Promise<ConversationTicket[]> {
    const { data, error } = await supabase
      .from('conversation_tickets')
      .select(`
        *,
        customer: customers (*)
      `)
      .eq('client_id', clientId)
      .order('last_message_at', { ascending: false });

    if (error) throw error;
    return data || [];
  },

  async getTicketById(ticketId: string): Promise<ConversationTicket | null> {
    const { data, error } = await supabase
      .from('conversation_tickets')
      .select(`
        *,
        customer: customers (*)
      `)
      .eq('id', ticketId)
      .single();

    if (error) throw error;
    return data;
  },

  async createOrUpdateTicket(
    clientId: string,
    chatId: string,
    instanceId: string,
    title: string,
    phoneNumber: string,
    lastMessage: string,
    lastMessageTime: string
  ): Promise<string> {
    try {
      // Verificar se j√° existe um ticket para este chat_id
      const { data: existingTicket, error: selectError } = await supabase
        .from('conversation_tickets')
        .select('id')
        .eq('client_id', clientId)
        .eq('chat_id', chatId)
        .single();

      if (selectError && selectError.code !== 'PGRST116') {
        console.error('Erro ao verificar ticket existente:', selectError);
        throw selectError;
      }

      if (existingTicket) {
        // Atualizar ticket existente
        const { error: updateError } = await supabase
          .from('conversation_tickets')
          .update({
            instance_id: instanceId,
            title: title,
            last_message_preview: lastMessage,
            last_message_at: lastMessageTime,
            updated_at: new Date().toISOString()
          })
          .eq('id', existingTicket.id);

        if (updateError) {
          console.error('Erro ao atualizar ticket:', updateError);
          throw updateError;
        }

        console.log(`Ticket atualizado: ${existingTicket.id}`);
        return existingTicket.id;
      } else {
        // Criar novo ticket
        const { data: newTicket, error: insertError } = await supabase
          .from('conversation_tickets')
          .insert({
            client_id: clientId,
            chat_id: chatId,
            instance_id: instanceId,
            title: title,
            status: 'open',
            priority: 1,
            last_message_preview: lastMessage,
            last_message_at: lastMessageTime
          })
          .select('id')
          .single();

        if (insertError) {
          console.error('Erro ao criar ticket:', insertError);
          throw insertError;
        }

        console.log(`Ticket criado: ${newTicket.id}`);
        return newTicket.id;
      }
    } catch (error) {
      console.error('Erro ao criar ou atualizar ticket:', error);
      throw error;
    }
  },

  async getTicketMessages(ticketId: string, limit: number = 50): Promise<TicketMessage[]> {
    const { data, error } = await supabase
      .from('ticket_messages')
      .select('*')
      .eq('ticket_id', ticketId)
      .order('timestamp', { ascending: false })
      .limit(limit);

    if (error) throw error;
    return data || [];
  },

  async addTicketMessage(message: Omit<TicketMessage, 'id'>): Promise<TicketMessage> {
    const { data, error } = await supabase
      .from('ticket_messages')
      .insert(message)
      .select('*')
      .single();

    if (error) throw error;
    return data;
  },

  async updateTicketStatus(ticketId: string, status: string): Promise<void> {
    const { error } = await supabase
      .from('conversation_tickets')
      .update({ status: status, updated_at: new Date().toISOString() })
      .eq('id', ticketId);

    if (error) throw error;
  },

  async assignTicketToQueue(ticketId: string, queueId: string): Promise<void> {
    const { error } = await supabase
      .from('conversation_tickets')
      .update({ assigned_queue_id: queueId, updated_at: new Date().toISOString() })
      .eq('id', ticketId);

    if (error) throw error;
  },

  async removeTicketFromQueue(ticketId: string): Promise<void> {
    const { error } = await supabase
      .from('conversation_tickets')
      .update({ assigned_queue_id: null, updated_at: new Date().toISOString() })
      .eq('id', ticketId);

    if (error) throw error;
  },

  async updateTicketTags(ticketId: string, tags: string[]): Promise<void> {
    const { error } = await supabase
      .from('conversation_tickets')
      .update({ tags: tags, updated_at: new Date().toISOString() })
      .eq('id', ticketId);

    if (error) throw error;
  },

  normalizePhoneNumber(phoneNumber: string): string {
    let cleanedNumber = phoneNumber.replace(/\D/g, '');

    if (cleanedNumber.length < 10) {
      return cleanedNumber;
    }

    if (cleanedNumber.startsWith('55')) {
      cleanedNumber = cleanedNumber.slice(2);
    }

    return cleanedNumber;
  },

  formatPhoneForDisplay(phoneNumber: string): string {
    const cleanedNumber = this.normalizePhoneNumber(phoneNumber);

    if (cleanedNumber.length === 10) {
      return cleanedNumber.replace(/(\d{2})(\d{4})(\d{4})/, '($1) $2-$3');
    } else if (cleanedNumber.length === 11) {
      return cleanedNumber.replace(/(\d{2})(\d{5})(\d{4})/, '($1) $2-$3');
    }

    return phoneNumber;
  },

  validateAndFixTimestamp(timestamp: any): string {
    if (!timestamp) {
      return new Date().toISOString();
    }

    let date: Date;

    if (typeof timestamp === 'number') {
      if (timestamp.toString().length === 10) {
        date = new Date(timestamp * 1000);
      } else {
        date = new Date(timestamp);
      }
    } else if (typeof timestamp === 'string') {
      date = new Date(timestamp);
    } else {
      return new Date().toISOString();
    }

    if (isNaN(date.getTime()) || date.getFullYear() > 2030) {
      return new Date().toISOString();
    }

    return date.toISOString();
  },

  async importConversationsFromWhatsApp(clientId: string): Promise<{ success: number; errors: number }> {
    try {
      console.log('üîÑ Iniciando importa√ß√£o de conversas para cliente:', clientId);
      
      // Buscar inst√¢ncias ativas do cliente
      const { data: instances, error: instancesError } = await supabase
        .from('whatsapp_instances')
        .select('instance_id, phone_number')
        .eq('client_id', clientId)
        .eq('status', 'connected');

      if (instancesError) {
        console.error('‚ùå Erro ao buscar inst√¢ncias:', instancesError);
        throw new Error('Falha ao buscar inst√¢ncias WhatsApp');
      }

      if (!instances || instances.length === 0) {
        throw new Error('Nenhuma inst√¢ncia WhatsApp conectada encontrada');
      }

      let totalSuccess = 0;
      let totalErrors = 0;

      // Testar m√∫ltiplas URLs do servidor WhatsApp
      const possibleUrls = [
        'http://localhost:3001',
        'http://127.0.0.1:3001',
        'https://whatsapp-server.yourdomain.com',
        'http://192.168.1.100:3001'
      ];

      for (const instance of instances) {
        console.log(`üì± Processando inst√¢ncia: ${instance.instance_id}`);
        
        let chatsData = null;
        let serverUrl = null;

        // Tentar cada URL at√© encontrar uma que funcione
        for (const url of possibleUrls) {
          try {
            console.log(`üåê Testando URL: ${url}/chats/${instance.instance_id}`);
            
            const response = await fetch(`${url}/chats/${instance.instance_id}`, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
              },
              signal: AbortSignal.timeout(10000) // 10 segundos timeout
            });

            if (response.ok) {
              const data = await response.json();
              if (data && (Array.isArray(data) || (data.chats && Array.isArray(data.chats)))) {
                chatsData = Array.isArray(data) ? data : data.chats;
                serverUrl = url;
                console.log(`‚úÖ Conectado com sucesso em: ${url}`);
                break;
              }
            }
          } catch (error) {
            console.log(`‚ùå Falha em ${url}:`, error);
            continue;
          }
        }

        if (!chatsData || !serverUrl) {
          console.error(`‚ùå N√£o foi poss√≠vel conectar em nenhuma URL para inst√¢ncia ${instance.instance_id}`);
          totalErrors++;
          continue;
        }

        console.log(`üìä ${chatsData.length} conversas encontradas para ${instance.instance_id}`);

        // Processar cada conversa
        for (const chat of chatsData) {
          try {
            const chatId = chat.id?.user || chat.id?._serialized || chat.chatId || chat.id;
            
            if (!chatId) {
              console.log('‚ö†Ô∏è Chat sem ID v√°lido, pulando...');
              totalErrors++;
              continue;
            }

            // Extrair nome do contato com m√∫ltiplas estrat√©gias
            let contactName = 'Contato sem nome';
            
            // Estrat√©gia 1: Nome direto do chat
            if (chat.name && chat.name.trim() && !chat.name.includes('@')) {
              contactName = chat.name.trim();
            }
            // Estrat√©gia 2: pushName da √∫ltima mensagem
            else if (chat.lastMessage?.author || chat.lastMessage?.pushName) {
              const authorName = chat.lastMessage.author || chat.lastMessage.pushName;
              if (authorName && !authorName.includes('@') && !authorName.match(/^\d+$/)) {
                contactName = authorName.trim();
              }
            }
            // Estrat√©gia 3: Nome do contato da agenda
            else if (chat.contact?.name || chat.contact?.pushname) {
              const phoneName = chat.contact.name || chat.contact.pushname;
              if (phoneName && !phoneName.includes('@') && !phoneName.match(/^\d+$/)) {
                contactName = phoneName.trim();
              }
            }
            // Estrat√©gia 4: Buscar perfil completo via API para obter nome da imagem
            else {
              try {
                const profileResponse = await fetch(`${serverUrl}/contact/${instance.instance_id}/${chatId}`, {
                  method: 'GET',
                  headers: { 'Content-Type': 'application/json' },
                  signal: AbortSignal.timeout(5000)
                });
                
                if (profileResponse.ok) {
                  const profileData = await profileResponse.json();
                  console.log(`üë§ Dados do perfil para ${chatId}:`, profileData);
                  
                  // Tentar extrair nome do perfil
                  const profileName = profileData.name || 
                                    profileData.pushname || 
                                    profileData.notify || 
                                    profileData.verifiedName ||
                                    profileData.businessProfile?.name;
                  
                  if (profileName && !profileName.includes('@') && !profileName.match(/^\d+$/)) {
                    contactName = profileName.trim();
                    console.log(`‚úÖ Nome obtido do perfil: ${contactName}`);
                  }
                }
              } catch (profileError) {
                console.log(`‚ö†Ô∏è N√£o foi poss√≠vel obter perfil para ${chatId}:`, profileError);
              }
            }

            // Extrair e normalizar n√∫mero de telefone
            const phoneNumber = this.normalizePhoneNumber(chatId);
            
            // Formatar nome final
            const finalName = this.formatCustomerName(contactName, phoneNumber);

            // Preparar √∫ltima mensagem
            const lastMessage = chat.lastMessage?.body || 
                              chat.lastMessage?.content || 
                              chat.lastMessage?.text ||
                              (chat.lastMessage?.type !== 'text' ? `[${chat.lastMessage?.type || 'M√≠dia'}]` : '') ||
                              'Sem mensagens';

            const lastMessageTime = this.validateAndFixTimestamp(
              chat.lastMessage?.timestamp || 
              chat.lastMessage?.t || 
              chat.timestamp || 
              Date.now()
            );

            console.log(`üíæ Salvando conversa: ${finalName} (${phoneNumber})`);

            // Criar ou atualizar ticket
            const ticketId = await this.createOrUpdateTicket(
              clientId,
              chatId,
              instance.instance_id,
              finalName,
              phoneNumber,
              lastMessage,
              lastMessageTime
            );

            // Buscar ou criar cliente
            let customer = await customersService.findByPhone(clientId, phoneNumber);
            if (!customer) {
              customer = await customersService.createCustomer({
                client_id: clientId,
                name: finalName,
                phone: phoneNumber,
                whatsapp_chat_id: chatId
              });
              console.log(`üë§ Cliente criado: ${customer.name}`);
            } else if (customer.name !== finalName && !customer.name.startsWith('Contato ')) {
              // Atualizar nome se encontramos um nome melhor
              await customersService.updateCustomer(customer.id, {
                name: finalName,
                whatsapp_chat_id: chatId
              });
              console.log(`üë§ Cliente atualizado: ${finalName}`);
            }

            totalSuccess++;

          } catch (chatError) {
            console.error('‚ùå Erro ao processar chat:', chat, chatError);
            totalErrors++;
          }
        }
      }

      console.log(`‚úÖ Importa√ß√£o conclu√≠da: ${totalSuccess} sucessos, ${totalErrors} erros`);
      return { success: totalSuccess, errors: totalErrors };

    } catch (error) {
      console.error('‚ùå Erro na importa√ß√£o:', error);
      throw error;
    }
  },

  // Fun√ß√£o para formatar nome do cliente
  formatCustomerName(rawName: string, phoneNumber: string): string {
    if (!rawName || rawName.trim() === '') {
      return this.formatPhoneForDisplay(phoneNumber);
    }

    const cleanName = rawName.trim();
    
    // Se √© apenas um n√∫mero, usar formato de telefone
    if (/^\d+$/.test(cleanName)) {
      return this.formatPhoneForDisplay(phoneNumber);
    }
    
    // Se cont√©m @ (email), usar telefone
    if (cleanName.includes('@')) {
      return this.formatPhoneForDisplay(phoneNumber);
    }
    
    // Se √© muito curto (menos de 2 caracteres), usar telefone
    if (cleanName.length < 2) {
      return this.formatPhoneForDisplay(phoneNumber);
    }
    
    // Se parece com um ID de usu√°rio, usar telefone
    if (cleanName.startsWith('user_') || cleanName.startsWith('contact_')) {
      return this.formatPhoneForDisplay(phoneNumber);
    }
    
    // Nome v√°lido - capitalizar primeira letra de cada palavra
    return cleanName
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  },

  // Fun√ß√£o para formatar n√∫mero de telefone para exibi√ß√£o
  formatPhoneNumber(phoneNumber: string): string {
    const cleaned = ('' + phoneNumber).replace(/\D/g, '');
    const match = cleaned.match(/^(\d{2})(\d{4,5})(\d{4})$/);
    if (match) {
      return '(' + match[1] + ') ' + match[2] + '-' + match[3];
    }
    return phoneNumber;
  },
};
