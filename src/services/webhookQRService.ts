// Servi√ßo para gerenciar webhooks de QR Code e fallbacks
import { toast } from "@/hooks/use-toast";

interface QRCodeWebhookData {
  event: 'qrcode.updated';
  instance: {
    name: string;
    id: number;
  };
  date: {
    qrcode: {
      code: string;
      base64: string;
    };
  };
}

interface QRCodeStorage {
  instanceId: string;
  qrCode: string;
  timestamp: number;
  source: 'webhook' | 'polling';
}

class WebhookQRService {
  private qrCodeStorage = new Map<string, QRCodeStorage>();
  private listeners = new Map<string, ((qrData: QRCodeStorage) => void)[]>();
  private pollTimeouts = new Map<string, NodeJS.Timeout>();

  // ============ WEBHOOK RECEIVER ============
  async setupWebhookListener() {
    // Event listener para webhooks via MessageChannel/postMessage
    window.addEventListener('qrcode-webhook', (event: any) => {
      const data = event.detail as QRCodeWebhookData;
      this.handleQRCodeWebhook(data);
    });

    console.log('üéØ [WEBHOOK] Listener de webhooks configurado');
  }

  private handleQRCodeWebhook(data: QRCodeWebhookData) {
    try {
      console.log('üì® [WEBHOOK] QR Code recebido via webhook:', data);
      
      const instanceId = data.instance.name;
      const qrCode = data.date.qrcode.base64;
      
      if (!qrCode) {
        console.warn('‚ö†Ô∏è [WEBHOOK] QR Code vazio no webhook');
        return;
      }

      const qrData: QRCodeStorage = {
        instanceId,
        qrCode,
        timestamp: Date.now(),
        source: 'webhook'
      };

      // Armazenar QR Code
      this.qrCodeStorage.set(instanceId, qrData);
      
      // Notificar listeners
      this.notifyListeners(instanceId, qrData);
      
      console.log(`‚úÖ [WEBHOOK] QR Code processado para ${instanceId}`);
      
    } catch (error) {
      console.error('‚ùå [WEBHOOK] Erro ao processar webhook:', error);
    }
  }

  // ============ FALLBACK POLLING ============
  startFallbackPolling(instanceId: string, codechatService: any, maxAttempts: number = 30) {
    // Limpar polling anterior se existir
    this.stopFallbackPolling(instanceId);
    
    console.log(`üîÑ [WEBHOOK-FALLBACK] Iniciando polling para ${instanceId}`);
    
    let attempts = 0;
    
    const pollFunction = async () => {
      try {
        attempts++;
        console.log(`üîç [WEBHOOK-FALLBACK] Tentativa ${attempts}/${maxAttempts} - ${instanceId}`);
        
        // Verificar se j√° temos QR Code via webhook
        const existing = this.qrCodeStorage.get(instanceId);
        if (existing && existing.source === 'webhook') {
          console.log(`‚úÖ [WEBHOOK-FALLBACK] QR Code j√° recebido via webhook`);
          return;
        }
        
        // Tentar buscar via API
        const response = await codechatService.getInstanceDetails(instanceId);
        const qrCode = this.extractQRFromResponse(response);
        
        if (qrCode) {
          console.log(`üéØ [WEBHOOK-FALLBACK] QR Code encontrado via polling`);
          
          const qrData: QRCodeStorage = {
            instanceId,
            qrCode,
            timestamp: Date.now(),
            source: 'polling'
          };
          
          this.qrCodeStorage.set(instanceId, qrData);
          this.notifyListeners(instanceId, qrData);
          return;
        }
        
        // Verificar status da inst√¢ncia para detectar inst√¢ncias mortas
        const statusData = await codechatService.getInstanceStatus(instanceId);
        
        // Verificar se inst√¢ncia est√° "morta" (connecting + OFFLINE por muito tempo)
        const isDeadInstance = (
          statusData.state === 'connecting' && 
          response.connectionStatus === 'OFFLINE' && 
          attempts >= 10 // Ap√≥s 10 tentativas (30 segundos)
        );
        
        if (isDeadInstance) {
          console.log(`üíÄ [WEBHOOK-FALLBACK] Inst√¢ncia morta detectada: state=${statusData.state}, status=${response.connectionStatus}`);
          this.tryInstanceRestart(instanceId, codechatService);
          return;
        }
        
        // Verificar se inst√¢ncia foi conectada
        if (statusData.state === 'open') {
          console.log(`üéâ [WEBHOOK-FALLBACK] Inst√¢ncia conectada durante polling`);
          return;
        }
        
        // Continuar polling se n√£o chegou no limite
        if (attempts < maxAttempts) {
          const timeout = setTimeout(pollFunction, 3000);
          this.pollTimeouts.set(instanceId, timeout);
        } else {
          console.warn(`‚ö†Ô∏è [WEBHOOK-FALLBACK] Timeout ap√≥s ${maxAttempts} tentativas`);
          
          // Se chegou ao limite, tentar restart da inst√¢ncia morta
          const finalStatus = await codechatService.getInstanceStatus(instanceId);
          const finalDetails = await codechatService.getInstanceDetails(instanceId);
          
          if (finalStatus.state === 'connecting' && finalDetails.connectionStatus === 'OFFLINE') {
            console.log(`üîÑ [WEBHOOK-FALLBACK] For√ßando restart de inst√¢ncia morta ap√≥s timeout`);
            this.tryInstanceRestart(instanceId, codechatService);
          }
        }
        
      } catch (error) {
        console.warn(`‚ö†Ô∏è [WEBHOOK-FALLBACK] Erro na tentativa ${attempts}:`, error);
        
        if (attempts < maxAttempts) {
          const timeout = setTimeout(pollFunction, 3000);
          this.pollTimeouts.set(instanceId, timeout);
        }
      }
    };
    
    // Iniciar primeiro poll
    pollFunction();
  }

  stopFallbackPolling(instanceId: string) {
    const timeout = this.pollTimeouts.get(instanceId);
    if (timeout) {
      clearTimeout(timeout);
      this.pollTimeouts.delete(instanceId);
      console.log(`üõë [WEBHOOK-FALLBACK] Polling parado para ${instanceId}`);
    }
  }

  // ============ RESTART DE INST√ÇNCIA "MORTA" ============
  private async tryInstanceRestart(instanceId: string, codechatService: any) {
    try {
      console.log(`üîÑ [RESTART] Tentando reiniciar inst√¢ncia morta: ${instanceId}`);
      
      // Parar polling atual
      this.stopFallbackPolling(instanceId);
      
      toast({
        title: "üîÑ Reiniciando Inst√¢ncia",
        description: "Detectada inst√¢ncia morta, reiniciando...",
      });
      
      // Etapa 1: Tentar deletar inst√¢ncia existente
      try {
        console.log(`üóëÔ∏è [RESTART] Deletando inst√¢ncia morta...`);
        await codechatService.deleteInstance(instanceId);
        console.log(`‚úÖ [RESTART] Inst√¢ncia deletada`);
        
        // Aguardar um pouco antes de recriar
        await new Promise(resolve => setTimeout(resolve, 3000));
        
      } catch (deleteError) {
        console.warn(`‚ö†Ô∏è [RESTART] Erro ao deletar (pode n√£o existir):`, deleteError);
      }
      
      // Etapa 2: Recriar inst√¢ncia
      console.log(`üìù [RESTART] Recriando inst√¢ncia...`);
      const createResult = await codechatService.createInstance(instanceId);
      
      if (!createResult.success && createResult.status !== 'already_exists') {
        throw new Error(`Falha ao recriar: ${createResult.error}`);
      }
      
      console.log(`‚úÖ [RESTART] Inst√¢ncia recriada`);
      
      // Aguardar mais um pouco antes de conectar
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Etapa 3: Reconectar
      console.log(`üîå [RESTART] Reconectando inst√¢ncia...`);
      const connectResult = await codechatService.connectInstance(instanceId);
      
      if (!connectResult.success) {
        throw new Error(`Falha na reconex√£o: ${connectResult.error}`);
      }
      
      console.log(`üéâ [RESTART] Inst√¢ncia reconectada com sucesso`);
      
      // Etapa 4: Reiniciar polling com timeout menor
      console.log(`üîç [RESTART] Reiniciando polling otimizado...`);
      this.startFallbackPolling(instanceId, codechatService, 20); // Menos tentativas
      
      toast({
        title: "‚úÖ Inst√¢ncia Reiniciada",
        description: "Tentando gerar novo QR Code...",
      });
      
    } catch (error) {
      console.error(`‚ùå [RESTART] Erro ao reiniciar inst√¢ncia:`, error);
      
      toast({
        title: "‚ùå Erro no Restart",
        description: `Falha ao reiniciar: ${error.message}`,
        variant: "destructive",
      });
      
      // Se o restart falhou, limpar tudo
      this.clearQRCode(instanceId);
    }
  }

  // ============ EXTRA√á√ÉO DE QR CODE MELHORADA ============
  private extractQRFromResponse(response: any): string | null {
    console.log(`üîç [QR-EXTRACT] Analisando resposta:`, {
      hasWhatsapp: !!response?.Whatsapp,
      hasQrcode: !!response?.qrcode,
      hasData: !!response?.data,
      connectionStatus: response?.connectionStatus,
      state: response?.Whatsapp?.connection?.state
    });
    
    // Verificar m√∫ltiplos campos onde QR Code pode estar
    const possiblePaths = [
      // Campos principais do CodeChat
      response?.Whatsapp?.qrcode?.base64,
      response?.Whatsapp?.qrcode?.code,
      response?.Whatsapp?.qr?.base64,
      response?.Whatsapp?.qr,
      response?.qrcode?.base64,
      response?.qrcode?.code,
      response?.qr?.base64,
      response?.qr,
      response?.data?.qrcode?.base64,
      response?.data?.qr,
      response?.instance?.qrcode?.base64,
      response?.instance?.qr,
      response?.qrCode,
      response?.base64,
      // Campos adicionais que podem existir
      response?.Auth?.qrcode,
      response?.Auth?.qr,
    ];

    for (const path of possiblePaths) {
      if (typeof path === 'string' && path.length > 50) {
        console.log(`üéØ [QR-EXTRACT] QR Code encontrado, tamanho: ${path.length}`);
        
        // Verificar se √© base64 v√°lido
        if (path.startsWith('data:image/') || path.includes('base64')) {
          return path;
        }
        // Se for string longa mas n√£o base64, pode ser c√≥digo QR texto
        if (path.length > 100 && !path.includes(' ')) {
          // Se j√° n√£o cont√©m prefixo, adicionar
          if (!path.startsWith('data:image/')) {
            return `data:image/png;base64,${path}`;
          }
          return path;
        }
      }
    }

    console.log(`‚ùå [QR-EXTRACT] QR Code n√£o encontrado na resposta`);
    return null;
  }

  // ============ LISTENERS ============
  addQRCodeListener(instanceId: string, callback: (qrData: QRCodeStorage) => void) {
    if (!this.listeners.has(instanceId)) {
      this.listeners.set(instanceId, []);
    }
    this.listeners.get(instanceId)!.push(callback);
    
    // Se j√° temos QR Code, notificar imediatamente
    const existing = this.qrCodeStorage.get(instanceId);
    if (existing) {
      callback(existing);
    }
  }

  removeQRCodeListener(instanceId: string, callback: (qrData: QRCodeStorage) => void) {
    const listeners = this.listeners.get(instanceId);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  private notifyListeners(instanceId: string, qrData: QRCodeStorage) {
    const listeners = this.listeners.get(instanceId);
    if (listeners) {
      listeners.forEach(callback => {
        try {
          callback(qrData);
        } catch (error) {
          console.error('‚ùå [WEBHOOK] Erro em listener:', error);
        }
      });
    }
  }

  // ============ P√öBLICO ============
  getQRCode(instanceId: string): QRCodeStorage | null {
    return this.qrCodeStorage.get(instanceId) || null;
  }

  hasQRCode(instanceId: string): boolean {
    return this.qrCodeStorage.has(instanceId);
  }

  clearQRCode(instanceId: string) {
    this.qrCodeStorage.delete(instanceId);
    this.stopFallbackPolling(instanceId);
    this.listeners.delete(instanceId);
  }

  cleanup() {
    // Limpar todos os timeouts
    this.pollTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.pollTimeouts.clear();
    
    // Limpar storages
    this.qrCodeStorage.clear();
    this.listeners.clear();
    
    console.log('üßπ [WEBHOOK] Cleanup completo');
  }
}

// Inst√¢ncia singleton
export const webhookQRService = new WebhookQRService();

// Inicializar automaticamente
webhookQRService.setupWebhookListener();